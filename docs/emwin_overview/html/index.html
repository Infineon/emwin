<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEGGER emWin graphics library 5.48.1: SEGGER emWin Graphics Library 5.48.1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEGGER emWin graphics library 5.48.1</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SEGGER emWin Graphics Library 5.48.1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>emWin is an embedded graphic library and graphical user interface (GUI) framework. It provides an efficient, processor- and display- controller-independent GUI for any application that operates with a graphical display including home appliances, automotive, IoT, and industrial. It is compatible with single-task and multi-task environments. Developed by SEGGER Microcontroller, emWin is extremely popular in the embedded industry. Cypress has licensed the emWin library from SEGGER and offers it for free to its customers.</p>
<p><b>Features:</b></p><ul>
<li>2-D Graphics Library</li>
<li>Displaying bitmap files</li>
<li>Fonts</li>
<li>Memory Devices</li>
<li>Multi-task (RTOS)</li>
<li>Window Manager</li>
<li>Window Objects (Widgets)</li>
<li>Virtual Screens / Virtual Pages</li>
<li>Pointer Input Devices<ul>
<li>Touch screen support (user defined)</li>
<li>Sprites and Cursors</li>
</ul>
</li>
<li>Anti-aliasing</li>
<li>Language Support<ul>
<li>Multi-codepages support</li>
<li>Unicode support</li>
<li>Right-to-left and bidirectional text support</li>
</ul>
</li>
<li>Display Drivers<ul>
<li>BitPlains</li>
<li>CompactColor_16</li>
<li>FlexColor</li>
<li>Lin</li>
<li>SPage</li>
<li>Template</li>
</ul>
</li>
<li>PC Tools to support emWin GUI development (such as Bitmap Converter and GUIBuilder)</li>
<li>Toolchains<ul>
<li>GNU Arm Embedded v7</li>
<li>Arm Compiler v6</li>
<li>IAR v8</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="section_emwin_general"></a>
General Description</h1>
<p>Include GUI.h to access all the functions and other declarations in this library. <a class="el" href="index.html#group_emwin_quick_start">Quick Start Guide</a> is offered in this API Reference Guide.</p>
<p>For compatibility information, refer to <a class="el" href="index.html#section_emwin_toolchain">Supported Software and Tools</a>.</p>
<p>For differences between the middleware versions, refer to <a class="el" href="index.html#group_emwin_changelog">Changelog</a>.</p>
<p>Also, <a class="el" href="index.html#group_emwin_changelog">Changelog</a> describes the impact of the changes to your code.</p>
<p>The emWin library consists of the two major parts:</p><ul>
<li>emWin GUI Framework</li>
<li>emWin Display Drivers</li>
</ul>
<p>The GUI framework provides a display-independent API intended to work with graphics (drawing and moving windows on the display, animation, 2D graphics) and to process data from input devices (touch pads, buttons, etc...).</p>
<p>Display Drivers implements the abstraction layer between the GUI framework and display controllers. For a list of display controllers supported by each driver, refer to <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a>. All drivers require the application layer functionality that implements communication with the physical display controller through a supported communication interface (I2C, SPI parallel ,etc...). For more detail, refer to the <a class="el" href="index.html#group_emwin_display_driver_configuration">Display Driver Configuration</a> section. The figure below shows how the emWin graphics library integrates into a PSoC&amp;reg and 6 MCU project.</p>
<div class="image">
<img src="emwin_solution.png" alt="emwin_solution.png"/>
<div class="caption">
emWin Solution</div></div>
 <p>The emWin API is described in <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<h2><a class="anchor" id="group_emwin_package_structure"></a>
emWin Package Structure</h2>
<p>Cypress distributes emWin as a set of static libraries. The middleware package does not contain the emWin source code. The table below lists the following items:</p>
<table class="noborder">
<tr>
<td valign="top"><div class="image">
<img src="dir_structure.png" alt="dir_structure.png" width="243px"/>
</div>
   </td><td valign="top"><table class="doxtable">
<tr>
<th align="top">Directory </th><th align="top">Description  </th></tr>
<tr>
<td><b>Config</b>  </td><td>Contains the pre-customized emWin GUI Framework and Display Drivers configuration files. A full set of configuration files for each supported driver are stored in separate sub-folders (BitPlains, CompactColor_16, etc...). For information about all display drivers, included in the emWin package, distributed by Cypress, refer to the <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a> section. These configuration files define the environment(MbedOS, FreeRTOS, BareMetal, etc...), selected display driver, and hardware interface with a display.   </td></tr>
<tr>
<td><b>Config/MbedOS</b>  </td><td>Configuration files stored in this directory are intended to be used as part of an MbedOS-based application. For more detail, refer to the <a class="el" href="index.html#group_emwin_configuration">Configuration Considerations</a>.   </td></tr>
<tr>
<td><b>Config/ModusToolbox</b>  </td><td>Configuration files stored in this directory are intended to be used with ModusToolbox&trade; a development environment or any other third party tools, like Keil or IAR and can be executed either as part of the FreeRTOS application or as part of a BareMetal application. For more detail, refer to the <a class="el" href="index.html#group_emwin_configuration">Configuration Considerations</a>.   </td></tr>
<tr>
<td><b>docs</b>  </td><td>Contains the API Reference Guide and other supporting documentation.   </td></tr>
<tr>
<td><b>GUI</b>  </td><td>Contains a set of static libraries, pre-compiled for different configurations of user applications (toolchain, FPU usage, OS usage, input device usage), and a set of header files, to provide an interface to the emWin functionality. For more detail, refer to the <a class="el" href="index.html#group_emwin_configuration">Configuration Considerations</a>.   </td></tr>
<tr>
<td><b>GUI/COMPONENT_SOFTFP</b>  </td><td rowspan="2">Contains a set of emWin static libraries compiled with different floating-point operations implementation options. Implementation of floating point operations corresponds to the name of the parent directory, later in the table referred as <b>COMPONENT_&lt;FP_OPTION&gt;</b>. For more usage detail, refer to the <a class="el" href="index.html#group_emwin_configuration">Configuration Considerations</a>.   </td></tr>
<tr>
<td><b>GUI/COMPONENT_HARDFP</b>   </td></tr>
<tr>
<td><b>GUI/COMPONENT_&lt;FP_OPTION&gt;/<br />
COMPONENT_EMWIN_NOSNTS</b>  </td><td>A set of static libraries with no multi-tasking and no touch support. There is a library for each supported toolchain in a separate folder:<ul>
<li>TOOLCHAIN_ARM - Stores the static library for the Arm Compiler.</li>
<li>TOOLCHAIN_GCC_ARM - Stores the static library for the GCC compiler.</li>
<li>TOOLCHAIN_IAR - Stores the static library for the IAR compiler.   </li>
</ul>
</td></tr>
<tr>
<td><b>GUI/COMPONENT_&lt;FP_OPTION&gt;/<br />
COMPONENT_EMWIN_NOSTS</b>  </td><td>A set of static libraries with no multitasking support but with touch support. This directory has the same structure as the COMPONENT_EMWIN_NOSNTS directory.   </td></tr>
<tr>
<td><b>GUI/COMPONENT_&lt;FP_OPTION&gt;/<br />
COMPONENT_EMWIN_OSNTS</b>  </td><td>A set of static libraries with multitasking support but without the touch support. This directory has the same structure as the COMPONENT_EMWIN_NOSNTS directory.   </td></tr>
<tr>
<td><b>GUI/COMPONENT_&lt;FP_OPTION&gt;/<br />
COMPONENT_EMWIN_OSTS</b>  </td><td>A set of static libraries with multitasking support and with the touch support. This directory has the same structure as the COMPONENT_EMWIN_NOSNTS directory.   </td></tr>
<tr>
<td><b>GUI/Include</b>  </td><td>Contains a set of header files to provide an interface to the emWin functionality.   </td></tr>
<tr>
<td><b>Sample</b>  </td><td>Contains an application program showing many emWin features. All examples are also available at <a href="https://www.segger.com/emwin-samples.html"><b>www.segger.com/emwin-samples.html</b></a> For usage details, refer to <a class="el" href="index.html#group_emwin_quick_start">Quick Start Guide</a>.   </td></tr>
<tr>
<td><b>Tool</b>  </td><td><p class="starttd">Contains emWin PC tools to support emWin GUI development. Included tools:</p><ul>
<li>Bin2C</li>
<li>Bitmap Converter</li>
<li>emWinPlayer</li>
<li>emWinViever</li>
<li>GUIBuilder</li>
<li>JPEG2Movie</li>
<li>U2C</li>
</ul>
<p class="endtd">For tools usage instructions, refer to <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>   </p>
</td></tr>
</table>
</td></tr>
</table>
<h2><a class="anchor" id="group_emwin_display_drivers"></a>
Supported Display Drivers</h2>
<table class="doxtable">
<tr>
<th>Driver </th><th>Supported display controller / Purpose of driver </th><th>Supported bits/pixel  </th></tr>
<tr>
<td><b>GUIDRV_BitPlains</b> </td><td>This driver can be used for solutions without a display controller. It manages separate bit-plains for each color bit. This driver does not have any display-controller-specific code and can be used for solutions that require color bits in separate plains.  </td><td>1 - 8  </td></tr>
<tr>
<td><b>GUIDRV_CompactColor_16</b> </td><td><b>Ampire:</b> FSA506<br />
 <b>Epson:</b> S1D13742, S1D13743, S1D19122<br />
 <b>FocalTech:</b> FT1509<br />
 <b>Himax:</b> HX8301, HX8312A, HX8325A, HX8340, HX8347, HX8352, HX8352B, HX8353<br />
 <b>Hitachi:</b> HD66766, HD66772, HD66789<br />
 <b>Ilitek:</b> ILI9161, ILI9220, ILI9221, ILI9320, ILI9325, ILI9326, ILI9328, ILI9342, ILI9481<br />
 <b>LG Electronics:</b> LGDP4531, LGDP4551<br />
 <b>MagnaChip:</b> D54E4PA7551<br />
 <b>Novatek:</b> NT39122, NT7573<br />
 <b>OriseTech:</b> SPFD5408, SPFD54124C, SPFD5414D, SPFD5420A<br />
 <b>Renesas:</b> R61505, R61509, R61516, R61526, R61580, R63401<br />
 <b>Samsung:</b> S6D0110A, S6D0117, S6D0128, S6D0129, S6D04H0<br />
 <b>Sharp:</b> LCY-A06003, LR38825<br />
 <b>Sitronix:</b> ST7628, ST7637, ST7687, ST7712, ST7715, ST7735, ST7787, ST7789<br />
 <b>Solomon:</b> SSD1284, SSD1289, SSD1298, SSD1355, SSD1961, SSD1963, SSD2119<br />
 <b>Toshiba:</b> JBT6K71<br />
  </td><td>16  </td></tr>
<tr>
<td><b>GUIDRV_FlexColor</b> </td><td><b>Epson:</b> S1D19122<br />
 <b>FocalTech:</b> FT1509<br />
 <b>Himax:</b> HX8353, HX8325A, HX8357, HX8340, HX8347, HX8352A, HX8352B, HX8301, HX8367, HX8369<br />
 <b>Hitachi:</b> HD66772<br />
 <b>Ilitek:</b> ILI9320, ILI9325, ILI9328, ILI9335, ILI9338, ILI9340, ILI9341, ILI9342, ILI9163, ILI9481, ILI9486, ILI9488, ILI9220, ILI9221<br />
 <b>LG Electronics:</b> LGDP4531, LGDP4551, LGDP4525<br />
 <b>Lucid Display Technology:</b> LDT7138 <b>Novatek:</b> NT39122<br />
 <b>OriseTech:</b> SPFD5408, SPFD54124C, SPFD5414D<br />
 <b>Raio:</b> RA8870, RA8875<br />
 <b>Renesas:</b> R61505, R61516, R61526, R61580<br />
 <b>Samsung:</b> S6E63D6, S6D0117<br />
 <b>Sitronix:</b> ST7628, ST7637, ST7687, ST7735, ST7712, ST7775, ST7715, ST7789, ST7796<br />
 <b>Solomon:</b> SSD1284, SSD1289, SSD1298, SSD1355, SSD2119, SSD1963, SSD1961, SSD1351, SSD1353<br />
 <b>Syncoam:</b> SEPS525<br />
  </td><td>16, 18  </td></tr>
<tr>
<td><b>GUIDRV_Lin</b> </td><td>This driver can be used for display controllers with linear addressable video memory and direct interface. This driver does not have any display-controller-specific code.  </td><td>1, 2, 4, 8, 16, 24, 32  </td></tr>
<tr>
<td><b>GUIDRV_SPage</b> </td><td><b>Avant Electronics:</b> SBN0064G<br />
 <b>Epson:</b> S1D15605, S1D15606, S1D15607, S1D15608, S1D15705, S1D15710, S1D15714, S1D15E05, S1D15E06, S1D15719, S1D15721<br />
 <b>Hitachi:</b> HD61202<br />
 <b>Integrated Solutions Technology:</b> IST3020, IST3501<br />
 <b>New Japan Radio Company:</b> NJU6676<br />
 <b>Novatek:</b> NT7502, NT7534, NT7538, NT75451<br />
 <b>OriseTech:</b> SPLC502B<br />
 <b>Samsung:</b> S6B0108 (KS0108), S6B0713, S6B0719, S6B0724, S6B1713<br />
 <b>Sino Wealth:</b> SH1101A<br />
 <b>Sitronix:</b> ST7522, ST75256, ST75320, ST7565, ST7567, ST7570, ST7591<br />
 <b>Solomon:</b> SSD1303, SSD1305, SSD1306, SSD1309, SSD1805, SSD1815, SSD1821<br />
 <b>Sunplus:</b> SPLC501C<br />
 <b>UltraChip:</b> UC1601, UC1606, UC1608, UC1610, UC1611, UC1628, UC1638, UC1701<br />
  </td><td>1, 2, 4  </td></tr>
<tr>
<td><b>GUIDRV_Template</b> </td><td>The driver template. Can be used as a starting point for writing a new custom display driver.  </td><td>1, 2, 4, 8, 16, 24, 32  </td></tr>
</table>
<p>For details on each driver, refer to section <b>Detailed display driver descriptions</b> on page 1186 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<h1><a class="anchor" id="group_emwin_quick_start"></a>
Quick Start Guide</h1>
<p>Cypress emWin middleware can be used in various Development Environments such as ModusToolbox, Mbed, etc. For more detail, refer to the <a class="el" href="index.html#section_emwin_toolchain">Supported Software and Tools</a>. The quickest way to get started is using Code Examples. Cypress continuously extends its portfolio of code examples at the <a href="http://www.cypress.com"><b>Cypress Semiconductor website</b></a> and at the <a href="https://github.com/cypresssemiconductorco"><b>Cypress Semiconductor GitHub</b></a>.</p>
<p>This quick start guide assumes that the environment is configured to use the PSoC 6 Peripheral Driver Library(psoc6pdl) for development and the PSoC 6 Peripheral Driver Library(psoc6pdl) is included in the project.</p>
<h2><a class="anchor" id="group_emwin_first_project"></a>
Create and run first emWin project</h2>
<p>This section provides the step-by-step instructions how to implement a simple "Hello World" application using emWin. The project requirements are listed below:</p><ul>
<li>Target display: The console on the user PC</li>
<li>Desired display resolution: 80x20 pixels</li>
<li>Color depth: 1 bit per pixel</li>
<li>No multitasking support</li>
<li>No touch screen support</li>
</ul>
<p>The following steps are required:</p>
<ol type="1">
<li>Add emWin to the project.<ul>
<li>For ModusToolbox, add emWin to the project using the Middleware selector.</li>
<li>For MbedOS, add emWin using the following command <div class="fragment"><div class="line">mbed add &lt;link to the emWin repository&gt;</div></div><!-- fragment --></li>
</ul>
</li>
<li>Configure the project to use the EMWIN_NOSNTS option, because multitasking and touch support is not required.<ul>
<li>For ModusToolbox, update the project's Makefile with the selected emWin option. <div class="fragment"><div class="line">COMPONENTS=EMWIN_NOSNTS</div></div><!-- fragment --></li>
<li>For MbedOS, add the selected emWin core option to mbed_app.json using the <b>target.components_add</b> command in the "target_overrides" section. <div class="fragment"><div class="line">{</div><div class="line"><span class="stringliteral">&quot;target_overrides&quot;</span>: {</div><div class="line">        <span class="stringliteral">&quot;*&quot;</span>:{</div><div class="line">            <span class="stringliteral">&quot;target.components_add&quot;</span>: [<span class="stringliteral">&quot;EMWIN_NOSNTS&quot;</span>]</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> For details on the option selection, refer to the <a class="el" href="index.html#group_emwin_project_configuration">Project Configuration</a> section.</li>
</ul>
</li>
<li><p class="startli">Create an emwin-config folder in the root of the project and copy the BitPlains driver configuration files to this folder.</p><ul>
<li>If ModusToolbox or a third-party IDE is used, copy the following files:<ul>
<li>emWin/Config/ModusToolbox/BitPlains/GUI_X.c</li>
<li>emWin/Config/ModusToolbox/BitPlains/GUIConf.c</li>
<li>emWin/Config/ModusToolbox/BitPlains/LCDConf.c</li>
<li>emWin/Config/ModusToolbox/BitPlains/LCDConf.h</li>
</ul>
</li>
<li>If Mbed is used, copy the following files:<ul>
<li>emWin/Config/MbedOS/BitPlains/GUI_X_Mbed.cpp</li>
<li>emWin/Config/MbedOS/BitPlains/GUIConf.cpp</li>
<li>emWin/Config/MbedOS/BitPlains/LCDConf.cpp</li>
<li>emWin/Config/MbedOS/BitPlains/LCDConf.h</li>
</ul>
</li>
</ul>
<p class="startli">For more details, refer to the <a class="el" href="index.html#group_emwin_project_configuration">Project Configuration</a> section.</p>
</li>
<li>Update the main.c/main.cpp with following includes: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cy_pdl.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;GUI.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;LCDConf.h&quot;</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For MbedOS, also include mbed.h.</dd></dl>
</li>
<li>Build the project. Compilation should be successful. Fix the compilation issues, if any, before moving to the next step.</li>
<li>Implement the STDOUT re-target to UART to enable the usage of the printf() function. This step is not required if Mbed is used as the Development Environment because the STDOUT re-target is already implemented on the MbedOS layer.</li>
<li>Configure the display driver - edit emWin config files in the previously created emwin-config folder:<ul>
<li>LCDConf.c/LCDConf.cpp:<ul>
<li>Set the physical display size to 80x20. In the emwin-config folder, update the XSIZE_PHYS/YSIZE_PHYS defines in the LCDConf.c/LCDConf.cpp as following: <div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Physical display size</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="preprocessor">#define XSIZE_PHYS 80</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 20</span></div></div><!-- fragment --></li>
<li>Add a routine to convert the display buffer to the ASCII pseudo-graphics. The code is provided below: <div class="fragment"><div class="line"><span class="preprocessor">#define TEXT_BUFFER_SIZE    (((XSIZE_PHYS + 2u) * YSIZE_PHYS) + 2u)</span></div><div class="line"><span class="keywordtype">char</span> * LCD_ConvertToText(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> x = 0;</div><div class="line">    <span class="keywordtype">int</span> y = 0;</div><div class="line">    U32 charIndex = 0;</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">char</span> textBuffer[TEXT_BUFFER_SIZE];</div><div class="line"></div><div class="line">    textBuffer[charIndex++] = 0x0Du;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(y = 0; y &lt; YSIZE_PHYS; y++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(x = 0; x &lt; XSIZE_PHYS; x++)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span>((_aPlain_0[y * BYTES_PER_LINE + x/8] &amp; (0x01u &lt;&lt; (x % 8))) != 0)</div><div class="line">            {</div><div class="line">                textBuffer[charIndex++] = <span class="charliteral">&#39;#&#39;</span>;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                textBuffer[charIndex++] = <span class="charliteral">&#39; &#39;</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        textBuffer[charIndex++] = 0x0Du;</div><div class="line">        textBuffer[charIndex++] = 0x0Au;</div><div class="line">    }</div><div class="line">    textBuffer[charIndex++] = 0x00u;</div><div class="line">    <span class="keywordflow">return</span>(textBuffer);</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
</li>
<li>LCDConf.h: Update the file with the LCD_ConvertToText() function prototype. <div class="fragment"><div class="line"><span class="keywordtype">char</span> * LCD_ConvertToText(<span class="keywordtype">void</span>);</div></div><!-- fragment --></li>
</ul>
</li>
<li>Update the main() routine with the following code: <div class="fragment"><div class="line">GUI_Init();</div><div class="line"></div><div class="line">GUI_Clear();</div><div class="line">GUI_DispStringAt(<span class="stringliteral">&quot;Hello World!&quot;</span>, 5, 2);</div><div class="line">GUI_DrawRect(0, 0, LCD_GetXSize() - 1, LCD_GetYSize() - 1);</div><div class="line">printf(LCD_ConvertToText());</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>(1)</div><div class="line">{</div><div class="line">   <span class="comment">// Infinite loop...</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>Build the application and program it into the target kit.</li>
<li>Launch the terminal on your PC and set the following configuration:<ul>
<li>Window size: 80x24</li>
<li>Auto line-wrap: Disabled (or the set window width is more than 80 symbols if there is no possibility to disable the auto line-wrap for the used terminal)</li>
</ul>
</li>
<li>Press the Reset button on the kit and observe the pseudo-graphical text in the terminal window: <div class="image">
<img src="terminal_out.png" alt="terminal_out.png"/>
<div class="caption">
Expected Result</div></div>
 </li>
</ol>
<h2><a class="anchor" id="group_emwin_demos"></a>
Run emWin examples and demos</h2>
<p>SEGGER provides many code examples to demonstrate various features of emWin. These examples can be found in the <em>Sample/Tutorial</em> directory or on the <a href="http://www.segger.com/emwin-samples.html"><b>SEGGER web page</b></a>.</p>
<p>Perform the following steps to run any demo:</p><ol type="1">
<li>Set-up emWin as described in the <a class="el" href="index.html#group_emwin_configuration">Configuration Considerations</a> section.</li>
<li>Add one of the demo sample files to your project.</li>
<li>Configure emWin as described in the section above.</li>
<li>Edit the main source file to include GUI.h and then call MainTask() as shown in the code that follows. All of the emWin examples use MainTask() as the entry point. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;GUI.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">   MainTask();</div><div class="line">   <span class="keywordflow">for</span>(;;)</div><div class="line">   {</div><div class="line">      </div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Compile and run the project.</li>
</ol>
<h1><a class="anchor" id="group_emwin_configuration"></a>
Configuration Considerations</h1>
<p>The emWin middleware contains a set of display drivers that support a number of different displays that operate on the top of the physical communication interface driver (GPIO, SCB, DMA, etc.) that is the part of the PSoC 6 Peripheral Driver Library (psoc6pdl). For a detailed list of display controllers supported by each driver, refer to <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a> section. This Configuration Considerations section guides how to set up the emWin middleware.</p>
<dl class="section note"><dt>Note</dt><dd>This section contains only basic configuration steps required to configure emWin. For detailed information on the emWin configuration, refer to <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The emWin middleware is not supported by the <a href="https://www.cypress.com/ModusToolboxDeviceConfig"><b>ModusToolbox Device Configurator Tool </b></a> which is part of <a href="https://www.cypress.com/products/modustoolbox-software-environment"><b>ModusToolbox</b></a>. The emWin middleware must be configured manually. </dd></dl>
<p>Configuring the emWin library consists of two major parts:</p>
<ol type="1">
<li><a class="el" href="index.html#group_emwin_project_configuration">Project Configuration</a></li>
<li><a class="el" href="index.html#group_emwin_display_driver_configuration">Display Driver Configuration</a></li>
</ol>
<h2><a class="anchor" id="group_emwin_project_configuration"></a>
Project Configuration</h2>
<p>The project configuration defines the set of configuration files and static libraries to be included in the project in order to adjust the emWin library according to the desired design requirements.</p>
<p>The required configuration steps are listed below:</p><ol type="1">
<li>Add emWin to the project.<ul>
<li>For ModusToolbox, add emWin to the project using the Middleware selector.</li>
<li>For MbedOS, add emWin using the following command <div class="fragment"><div class="line">mbed add &lt;link to the emWin repository&gt;</div></div><!-- fragment --></li>
</ul>
</li>
<li><p class="startli">Select and enable the emWin core option according to the project requirements. Available options:</p><ul>
<li><b>EMWIN_NOSNTS</b> - No multitasking and no touch support.</li>
<li><b>EMWIN_NOSTS</b> - No multitasking support, touch support.</li>
<li><b>EMWIN_OSNTS</b> - Multitasking support, no touch support.</li>
<li><b>EMWIN_OSTS</b> - Multitasking and touch support.</li>
</ul>
<p class="startli">To enable the selected core option in:</p><ul>
<li><b>ModusToolbox</b>: Update the project's Makefile with the selected emWin option. The example below demonstrates how to select the EMWIN_NOSNTS option. <div class="fragment"><div class="line">COMPONENTS=EMWIN_NOSNTS</div></div><!-- fragment --></li>
<li><b>MbedOS</b>: Add the selected emWin core option to mbed_app.json using the <b>target.components_add</b> command in the "target_overrides" section. The example below demonstrates how to select the EMWIN_NOSNTS option. <div class="fragment"><div class="line">{</div><div class="line"><span class="stringliteral">&quot;target_overrides&quot;</span>: {</div><div class="line">        <span class="stringliteral">&quot;*&quot;</span>:{</div><div class="line">            <span class="stringliteral">&quot;target.components_add&quot;</span>: [<span class="stringliteral">&quot;EMWIN_NOSNTS&quot;</span>]</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li><b>Other development environment</b>: Update the project settings to add the following paths:<ul>
<li>Add the "emWin/GUI/Include" catalog to the Include paths</li>
<li>Add the "emWin/GUI/COMPONENT_&lt;SELECTED_FPU_OPTION&gt;/COMPONENT_&lt;SELECTED_CORE_OPTION&gt;" catalog to the Include paths</li>
<li>Set up the linking of the library placed under the emWin/GUI/COMPONENT_&lt;SELECTED_FPU_OPTION&gt; /COMPONENT_&lt;SELECTED_CORE_OPTION&gt;/TOOLCHAIN_&lt;SELECTED_TOOLCHAIN&gt; catalog. SELECTED_TOOLCHAIN defines the toolchain used to build the project. The current version of the emWin library supports the following toolchains:<ul>
<li><b>ARM</b> - Arm Compiler 6 is used</li>
<li><b>GCC_ARM</b> - GCC Compiler is used</li>
<li><b>IAR</b> - IAR Compiler is used</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Select the display driver that supports the display controller used in the design. For information on display drivers and display controllers, supported by the emWin library, refer to the <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a> section.</li>
<li><p class="startli">Copy the required emWin config files to the project. These files are typically edited for a specific project, so Cypress recommends you copy the files into the separate emWin config folder in the root of your project. Depending on the selected development flow, go to emWin/Config/&lt;MbedOS or ModusToolbox&gt;/&lt;Selected Display Driver&gt; and copy the folder content to the previously created emWin config folder.</p><ul>
<li>For Mbed, copy all the files from the emWin/Config/MbedOS/&lt;Selected Display Driver&gt; folder.</li>
<li>For ModusToolbox and other development environments, copy the files from the emWin/Config/ModusToolbox/&lt;Selected Display Driver&gt; folder, but select only one of the GUI_X files depending on the OS being used.</li>
</ul>
<p class="startli">In the selected folder, you find the following files: </p><table class="doxtable">
<tr>
<th>Configuration file </th><th>Purpose  </th></tr>
<tr>
<td>GUI_X.c or GUI_X.cpp <br />
 GUI_X_&lt;OS_Name&gt;.c or GUI_X_&lt;OS_Name&gt;.cpp  </td><td>Contains a definition of the emWin timing routines and the kernel interface routines if RTOS is used. Depending on the RTOS used in the project, only one corresponding GUI_X_&lt;OS_Name&gt; file must be selected. If no is RTOS used, select the GUI_X.c file.   </td></tr>
<tr>
<td>GUIConf.c or GUIConf.cpp  </td><td>Configures available for emWin the RAM block and sets its size. This block is managed by the internal memory management system to allocate internal emWin data.   </td></tr>
<tr>
<td>LCDConf.c or LCDConf.cpp  </td><td>Configures the display driver parameters such as the size, color conversion, driver callback functions, hardware interface functions, etc.   </td></tr>
<tr>
<td>LCDConf.h  </td><td>The configuration of the used display driver(s).   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>In FreeRTOS, emWin uses mutex resource for multitasking support. To enable FreeRTOS mutex support, set configUSE_MUTEXES to 1 in the FreeRTOSConfig.h file.</dd></dl>
<p>Also, depending on the driver, you may find the following driver-specific files: </p><table class="doxtable">
<tr>
<th>Configuration file </th><th>Purpose  </th></tr>
<tr>
<td>LCDConf_CompactColor_16.h  </td><td>The specific configuration file for the CompactColor_16 driver. Defines configurations such as the display controller, data bus width, display mirroring options, and display hardware-access functions.   </td></tr>
<tr>
<td>GUIDRV_CompactColor_16.c<br />
 GUIDRV_CompactColor_16.h  </td><td>The CompactColor_16 display driver files. Do not modify!   </td></tr>
<tr>
<td>GUIDRV_Template.c<br />
 GUIDRV_Template.h  </td><td>The display driver template files. Can be used as a starting point for custom display driver implementation.   </td></tr>
<tr>
<td>LCDConf.h  </td><td>The configuration of the used display driver(s).   </td></tr>
</table>
</li>
</ol>
<p>For the application layer code required to set up emWin and display data, refer to the <a class="el" href="index.html#group_emwin_first_project">Create and run first emWin project</a> section</p>
<h2><a class="anchor" id="group_emwin_display_driver_configuration"></a>
Display Driver Configuration</h2>
<p>The drivers can be configured by modifying the emWin configuration files which contain all required information for the driver including the display- controller hardware interface. The display driver configuration includes the following steps:</p><ol type="1">
<li>Create a driver instance, set up the color conversion routines and link them to the desired layer.</li>
<li>Configure the display physical size.</li>
<li>Configure the display data RAM.</li>
<li>Configure the access to the display hardware.</li>
<li>Configure the driver specific functions, if any.</li>
<li>Update the LCD_X_DisplayDriver() callback function to handle all required commands from the driver.</li>
</ol>
<p>The drivers, included in the emWin package distributed by Cypress are listed in the <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a> section.</p>
<p>The following sections describe the steps required to configure each of the supported drivers:</p><ul>
<li><a class="el" href="index.html#group_emwin_bitplains_configuration">BitPlains Driver</a></li>
<li><a class="el" href="index.html#group_emwin_flexcolor_configuration">FlexColor Driver</a></li>
<li><a class="el" href="index.html#group_emwin_lin_configuration">Lin Driver</a></li>
<li><a class="el" href="index.html#group_emwin_spage_configuration">SPage Driver</a></li>
<li><a class="el" href="index.html#group_emwin_compactcolor16_configuration">CompactColor_16 Driver</a></li>
<li><a class="el" href="index.html#group_emwin_template_configuration">Template Driver</a></li>
</ul>
<h2><a class="anchor" id="group_emwin_bitplains_configuration"></a>
BitPlains Driver</h2>
<p>This section documents the main steps required to configure the BitPlains driver.</p>
<p>The configuration explanation is based on the pre-customized files that are part of the emWin library and available in the Config/MbedOS/BitPlains or Config/ModusToolbox/BitPlains catalog.</p>
<p>The LCD_X_Config() routine in the LCDConf.c/LCDConf.cpp files should implement the following functionality:</p><ol type="1">
<li>Create a GUIDRV_BitPlains driver instance with the desired palette and link it to the desired layer. The pre-customized LCDConf.c/LCDConf.cpp files implements creating of the GUIDRV_BitPlains driver instance witch the GUICC_1 (1-bpp black and white) palette and link it to the 1-st layer. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define COLOR_CONVERSION GUICC_1</span></div></div><!-- fragment --> <div class="fragment"><div class="line">GUI_DEVICE_CreateAndLink(GUIDRV_BITPLAINS, COLOR_CONVERSION, 0, 0);</div></div><!-- fragment --> The user can change the COLOR_CONVERSION value to set up some other palette. For more detail on using the proper palette mode, refer to the section <b>Colors</b> on page 1187 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</li>
<li>Configure the physical display size with the desired value. The pre-customized LCDConf.c/LCDConf.cpp files have configured physical display size with the default value 320x240 pixels. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define XSIZE_PHYS 240</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 320</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (LCD_GetSwapXY())</div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, YSIZE_PHYS, XSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, YSIZE_PHYS, XSIZE_PHYS);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, XSIZE_PHYS, YSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, XSIZE_PHYS, YSIZE_PHYS);</div><div class="line">}</div></div><!-- fragment --> The user can set a required display size by using the XSIZE_PHYS and YSIZE_PHYS defines.</li>
<li><p class="startli">Configure the display data RAM for the desired layer. The pre-customized LCDConf.c/LCDConf.cpp files have configured display data RAM for the 1-st layer to store a 1-bpp black-and- white picture with the 240x320 pixels resolution. See the corresponding code below.</p>
<p class="startli">Memory buffer allocation: </p><div class="fragment"><div class="line"><span class="preprocessor">#define XSIZE_PHYS 240</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 320</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#define BYTES_PER_LINE ((XSIZE_PHYS + 7) / 8)</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">static</span> U8 _aPlain_0[BYTES_PER_LINE * YSIZE_PHYS];</div></div><!-- fragment --><p class="startli">Display RAM data structure definition: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>{</div><div class="line">U8 * apVRAM[8];</div><div class="line">} _VRAM_Desc = {{</div><div class="line">_aPlain_0,</div><div class="line">}};</div></div><!-- fragment --><p> The apVRAM element is the array of pointers to the memory locations to be used by the driver for each bit plain. If the driver, for example, works in 1bpp mode, only the first 1 pointer is used (One plain for each bit of the color information).</p>
<p class="startli">Display RAM address assignment: </p><div class="fragment"><div class="line">LCD_SetVRAMAddrEx(0, (<span class="keywordtype">void</span> *)&amp;_VRAM_Desc);</div></div><!-- fragment --><p> The user can configure a required memory layout by allocating the necessary number of _aPlain arrays and adding them to the _VRAM_Desc structure. The example of the memory layout for GUICC_M111 (3-bpp, 8 colors) is provided below: </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Data arrays to be used by the display driver:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span> U8 _aPlain_0[BYTES_PER_LINE * YSIZE_PHYS];</div><div class="line"><span class="keyword">static</span> U8 _aPlain_1[BYTES_PER_LINE * YSIZE_PHYS];</div><div class="line"><span class="keyword">static</span> U8 _aPlain_2[BYTES_PER_LINE * YSIZE_PHYS];</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Structure to be passed to the driver</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>{</div><div class="line">U8 * apVRAM[8];</div><div class="line">} _VRAM_Desc = {</div><div class="line">    _aPlain_0,</div><div class="line">    _aPlain_1,</div><div class="line">    _aPlain_2,</div><div class="line">};</div></div><!-- fragment --></li>
</ol>
<p>It is also possible to add another user code if more configuration actions are required to achieve the desired parameters. For other configuration options of the BitPlains driver, refer to section <b>Additional run-time configuration</b> on page 1187 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<p>The LCD_X_DisplayDriver() routine implementation does not require any specific functionality in order to enable display operation with the parameters, set in scope of the LCD_X_Config() routine. The pre-customized LCDConf.c/LCDConf.cpp files implements the LCD_X_DisplayDriver() routine template. See the corresponding code below. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> LCD_X_DisplayDriver(<span class="keywordtype">unsigned</span> LayerIndex, <span class="keywordtype">unsigned</span> Cmd, <span class="keywordtype">void</span> * pData)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> r;</div><div class="line"></div><div class="line">    GUI_USE_PARA(LayerIndex);</div><div class="line">    GUI_USE_PARA(pData);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (Cmd)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> LCD_X_INITCONTROLLER:</div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// Called during the initialization process in order to set up the</span></div><div class="line">            <span class="comment">// display controller and put it into operation. If the display</span></div><div class="line">            <span class="comment">// controller is not initialized by any external routine, this needs</span></div><div class="line">            <span class="comment">// to be adapted by the customer...</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            r = 0;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            r = -1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> r;</div><div class="line">}</div></div><!-- fragment --><p> You can update this template to process other supported commands if they are required by the target application. For the descriptions of all the supported commands, refer to section <b>Commands passed to the callback function</b> on page 1182 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<p>The BitPlains display driver does not have any display controller specific code, so the user is responsible for implementing the functionality intended to update the physical display according to the display RAM data (_VRAM_Desc structure). For a possible approach example, refer to the <a class="el" href="index.html#group_emwin_first_project">Create and run first emWin project</a> section.</p>
<h2><a class="anchor" id="group_emwin_flexcolor_configuration"></a>
FlexColor Driver</h2>
<p>This section documents the main steps required to configure the FlexColor driver.</p>
<p>The explanation is based on the pre-customized files that are the part of emWin library and placed in the Config/MbedOS/FlexColor or Config/ModusToolbox/FlexColor catalog.</p>
<p>The LCD_X_Config() routine in the LCDConf.c/LCDConf.cpp files should implement the following functionality:</p><ol type="1">
<li><p class="startli">Create the GUIDRV_FlexColor driver instance with the desired palette and link it to the desired layer. The pre-customized LCDConf.c/LCDConf.cpp files implements creation of the GUIDRV_FlexColor driver instance witch the GUICC_M565 (16 bpp, red and blue swapped) palette and link it to the 1-st layer. See the corresponding code below: </p><div class="fragment"><div class="line"><span class="preprocessor">#define DISPLAY_DRIVER GUIDRV_FLEXCOLOR</span></div><div class="line"><span class="preprocessor">#define COLOR_CONVERSION GUICC_M565</span></div></div><!-- fragment --> <div class="fragment"><div class="line">GUI_DEVICE * pDevice;</div><div class="line">pDevice = GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);</div></div><!-- fragment --><p> The user can change COLOR_CONVERSION value to set up some other palette. For more information on palettes, refer to section Colors on page 1187 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<dl class="section note"><dt>Note</dt><dd>In some cases, you may need to set a value of the Entry Mode register of the display controller for its configuration. The FlexColor driver writes data to the display controller Entry Mode register in order to set the display orientation, overwriting value, set during the display initialization. To set a desired value of other bits in the Entry Mode register, write the Entry Mode value into the RegEntryMode field of the CONFIG_FLEXCOLOR structure and then pass it as a parameter of the GUIDRV_FlexColor_Config() function. The driver will combine the desired value with the required orientation bit values during the initialization process: <div class="fragment"><div class="line">CONFIG_FLEXCOLOR Config = {0};</div><div class="line">Config.RegEntryMode = DESIRED_ENTRY_MODE_REG_VALUE;</div><div class="line">GUIDRV_FlexColor_Config(pDevice, &amp;Config);</div></div><!-- fragment --></dd></dl>
</li>
<li>Configure the physical display size with the desired value. The pre-customized LCDConf.c/LCDConf.cpp files have configured the physical display size with the default value of 320x240 pixels. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define XSIZE_PHYS 240</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 320</span></div></div><!-- fragment --> <div class="fragment"><div class="line">LCD_SetSizeEx (0, XSIZE_PHYS,  YSIZE_PHYS);</div><div class="line">LCD_SetVSizeEx(0, VXSIZE_PHYS, VYSIZE_PHYS);</div></div><!-- fragment --> The user can set the custom display size using the XSIZE_PHYS and YSIZE_PHYS defines.</li>
<li>Configure the display data RAM for the desired layer. The FlexColor driver does not require allocation of the display data RAM buffer in scope of the LCDConf.c/LCDConf.cpp files. It uses the memory buffer allocated in the GUIConf.c/GUIConf.cpp files. The FlexColor display driver can be used with and without a display data cache that contains a complete copy of the content of the display data RAM in order to avoid reading operations from the display controller and increase the display performance. For details on the cache usage, refer to section GUIDRV_FlexColor on page 1193 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</li>
<li><p class="startli">Configure the display driver to work with the specified display controller. The pre-customized LCDConf.c/LCDConf.cpp files implements configuring the FlexColor display driver to work with the GUIDRV_FLEXCOLOR_F66709 controller set in the M16C0B8 (16bpp, no cache, 8 bit bus) operation mode. For a full list of supported display controllers, refer to the <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a> section. See the corresponding code below: </p><div class="fragment"><div class="line">GUI_PORT_API PortAPI = {0};</div></div><!-- fragment --> <div class="fragment"><div class="line">GUIDRV_FlexColor_SetFunc(pDevice, &amp;PortAPI, GUIDRV_FLEXCOLOR_F66709, GUIDRV_FLEXCOLOR_M16C0B8);</div></div><!-- fragment --><p> You can configure the FlexColor display driver to work with any supported display controller in any supported operation mode by changing values of the #3 and #4 parameters of the the GUIDRV_FlexColor_SetFunc() function. For all permitted values for these parameters, refer to section <b>GUIDRV_FlexColor_SetFunc()</b> on page 1196 of the <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a> for all permitted values for these parameters.</p>
<p class="startli">The provided template does not implement any hardware interface. The user is responsible for selecting the appropriate communication interface (I2C, SPI, GPIO, etc...) for the hardware interface implementation on the application layer and for the initialization of the corresponding fields of the PortAPI structure in scope of the LCD_X_Config() routine. The set of functions depends on the display controller operation mode. For example, if 16C0B8 (16bpp, no cache, 8 bit bus) is used, an 8-bit interface should be configured, if M16C0B16 (16bpp, no cache, 16 bit bus) is used then the 16-bit interface should be implemented and so on. For a description of each interface, refer to section <b>Required GUI_PORT_API routines</b> on page 1198.</p>
</li>
</ol>
<p>It is also possible to add another user code if more configuration actions are required to achieve the desired parameters. For more information, refer to section <b>Run-time configuration API</b> on page 1194 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<p>The LCD_X_DisplayDriver() routine requires the LCD_X_INITCONTROLLER command implementation in order to enable the display operation with the parameters, set in scope of the LCD_X_Config() routine. The pre-customized LCDConf.c/LCDConf.cpp files implements the LCD_X_DisplayDriver() routine template with the call of the empty function to handle the LCD_X_INITCONTROLLER command. See the corresponding code below.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _InitController(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line"> <span class="keywordtype">int</span> LCD_X_DisplayDriver(<span class="keywordtype">unsigned</span> LayerIndex, <span class="keywordtype">unsigned</span> Cmd, <span class="keywordtype">void</span> * pData)</div><div class="line"> {</div><div class="line">     <span class="keywordtype">int</span> r;</div><div class="line"></div><div class="line">     GUI_USE_PARA(LayerIndex);</div><div class="line">     GUI_USE_PARA(pData);</div><div class="line"></div><div class="line">     <span class="keywordflow">switch</span> (Cmd)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> LCD_X_INITCONTROLLER:</div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// Called during the initialization process in order to set up the</span></div><div class="line">            <span class="comment">// display controller and put it into operation. If the display</span></div><div class="line">            <span class="comment">// controller is not initialized by any external routine, this needs</span></div><div class="line">            <span class="comment">// to be adapted by the customer...</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            _InitController();</div><div class="line">            r = 0;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            r = -1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> r;</div><div class="line">}</div></div><!-- fragment --><p> The user is responsible for the _InitController() implementation with the initialization functionality for the used display controller. The user can also update this template to process any supported command if it is required by the target application. For the descriptions of all the supported commands, refer to the chapter <b>Commands passed to the callback function</b> on page 1182 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<h2><a class="anchor" id="group_emwin_lin_configuration"></a>
Lin Driver</h2>
<p>This section documents the main steps required to configure the Lin driver.</p>
<p>The explanation is based on the pre-customized files that are part of the emWin library and placed in the Config/MbedOS/Lin or Config/ModusToolbox/Lin catalog.</p>
<p>The LCD_X_Config() routine that is the part of LCDConf.c/LCDConf.cpp files should implement the following functionality:</p><ol type="1">
<li>Create the GUIDRV_Lin driver instance with the desired display orientation, color depth, palette, and link it to the desired layer. The pre-customized LCDConf.c/LCDConf.cpp files implements creating of the GUIDRV_LIN_32 option of the GUIDRV_Lin driver. This option defines the GUIDRV_Lin driver instance witch the following parameters:<ul>
<li>Orientation: Default</li>
<li>Color depth: 32-bpp</li>
<li>Palette: GUICC_8888 (32-bpp, 3-color components, the upper byte is used for alpha blending.)<br />
 and link it to the 1-st layer. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define COLOR_CONVERSION GUICC_8888</span></div><div class="line"><span class="preprocessor">#define DISPLAY_DRIVER GUIDRV_LIN_32</span></div></div><!-- fragment --> <div class="fragment"><div class="line">GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);</div></div><!-- fragment --> You can change the COLOR_CONVERSION value to set up some other palette. For more information on palettes, refer to section Colors on page 1187 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>. The orientation and color depth depends on the selected GUIDRV_Lin driver option and can be changed as well. For all supported GUIDRV_Lin driver options and configuration macros for each option, refer to section <b>Color depth and display orientation</b> on page 1210.</li>
</ul>
</li>
<li>Configure the physical display size with the desired value. The pre-customized LCDConf.c/LCDConf.cpp files have configured the physical display size with the default value of 320x240 pixels. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define XSIZE_PHYS 320</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 240</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (LCD_GetSwapXY())</div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, YSIZE_PHYS,   XSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, VYSIZE_PHYS,  VXSIZE_PHYS);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, XSIZE_PHYS,   YSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, VXSIZE_PHYS,  VYSIZE_PHYS);</div><div class="line">}</div></div><!-- fragment --> You can set the custom display size by using the XSIZE_PHYS/YSIZE_PHYS defines.</li>
<li>Configuring the display data RAM for the desired layer. The Lin driver does not require allocation of the display data RAM. This driver is working directly with the display controller video memory mapped to the CPU address space. The pre-customized files LCDConf.c/LCDConf.cpp set the address of the video RAM for 1-st layer to the value "0" by default. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define VRAM_ADDR 0</span></div></div><!-- fragment --> <div class="fragment"><div class="line">LCD_SetVRAMAddrEx(0, (<span class="keywordtype">void</span> *)VRAM_ADDR);</div></div><!-- fragment --> The user responsibility is to update the VRAM_ADDR macro with the correct value for the display controller being used.</li>
</ol>
<p>It is also possible to add another user code if more configuration actions are required to achieve the desired parameters. For more information, refer to the <b>Run-time configuration</b> section on page 1213 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<dl class="section note"><dt>Note</dt><dd>For all precompiled emWin libraries compile time parameter LCD_ENDIAN_BIG is set to "0", e.g. Little Endian mode.</dd></dl>
<p>The LCD_X_DisplayDriver() routine requires the LCD_X_INITCONTROLLER command implementation in order to enable the display operation with the parameters, set in scope of the LCD_X_Config() routine. The pre-customized LCDConf.c/LCDConf.cpp files implement the LCD_X_DisplayDriver() routine template with the call of the empty functions to handle the following commands:</p><ul>
<li>LCD_X_INITCONTROLLER</li>
<li>LCD_X_SETVRAMADDR</li>
<li>LCD_X_SETORG</li>
<li>LCD_X_SETLUTENTRY See the corresponding code below. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _InitController(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _SetVRAMAddr(<span class="keywordtype">void</span> * pVRAM)</div><div class="line">{</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _SetOrg(<span class="keywordtype">int</span> xPos, <span class="keywordtype">int</span> yPos)</div><div class="line">{</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _SetLUTEntry(LCD_COLOR Color, U8 Pos)</div><div class="line">{ </div><div class="line"></div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line"> <span class="keywordtype">int</span> LCD_X_DisplayDriver(<span class="keywordtype">unsigned</span> LayerIndex, <span class="keywordtype">unsigned</span> Cmd, <span class="keywordtype">void</span> * pData)</div><div class="line"> {</div><div class="line">     <span class="keywordtype">int</span> r;</div><div class="line">     <span class="comment">// void * p;</span></div><div class="line">   </div><div class="line">     <span class="keywordflow">switch</span> (Cmd)</div><div class="line">     {</div><div class="line">         <span class="comment">//</span></div><div class="line">         <span class="comment">// Required</span></div><div class="line">         <span class="comment">//</span></div><div class="line">         <span class="keywordflow">case</span> LCD_X_INITCONTROLLER:</div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// Called during the initialization process in order to set up the</span></div><div class="line">             <span class="comment">// display controller and put it into operation. If the display</span></div><div class="line">             <span class="comment">// controller is not initialized by any external routine, this needs</span></div><div class="line">             <span class="comment">// to be adapted by the customer...</span></div><div class="line">             <span class="comment">//</span></div><div class="line">             _InitController();</div><div class="line">             r = 0;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     </div><div class="line">         <span class="keywordflow">case</span> LCD_X_SETVRAMADDR:</div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// Required for setting the address of the video RAM for drivers</span></div><div class="line">             <span class="comment">// with memory mapped video RAM which is passed in the &#39;pVRAM&#39; element of p</span></div><div class="line">             <span class="comment">//</span></div><div class="line">             _SetVRAMAddr(((LCD_X_SETVRAMADDR_INFO *)pData)-&gt;pVRAM);</div><div class="line">             r = 0;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     </div><div class="line">         <span class="keywordflow">case</span> LCD_X_SETORG:</div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// Required for setting the display origin which is passed in the &#39;xPos&#39; and &#39;yPos&#39; element of p</span></div><div class="line">             <span class="comment">//</span></div><div class="line">             _SetOrg(((LCD_X_SETORG_INFO *)pData)-&gt;xPos, ((LCD_X_SETORG_INFO *)pData)-&gt;yPos);</div><div class="line">             r = 0;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     </div><div class="line">         <span class="keywordflow">case</span> LCD_X_SETLUTENTRY:</div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// Required for setting a lookup table entry which is passed in the &#39;Pos&#39; and &#39;Color&#39; element of p</span></div><div class="line">             <span class="comment">//</span></div><div class="line">             _SetLUTEntry(((LCD_X_SETLUTENTRY_INFO *)pData)-&gt;Color, ((LCD_X_SETLUTENTRY_INFO *)pData)-&gt;Pos);</div><div class="line">             r = 0;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     </div><div class="line">         <span class="keywordflow">case</span> LCD_X_ON:</div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// Required if the display controller should support switching on and off</span></div><div class="line">             <span class="comment">//</span></div><div class="line">             r = 0;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     </div><div class="line">         <span class="keywordflow">case</span> LCD_X_OFF:</div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// Required if the display controller should support switching on and off</span></div><div class="line">             <span class="comment">//</span></div><div class="line">             <span class="comment">// ...</span></div><div class="line">             r = 0;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     </div><div class="line">         <span class="keywordflow">default</span>:</div><div class="line">             r = -1;</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">     }</div><div class="line">   </div><div class="line">     <span class="keywordflow">return</span> r;</div><div class="line">}</div></div><!-- fragment --> The user is responsible for the _InitController() implementation with the initialization functionality for the used display controller. The user can also update this template to process any supported command if it is required by the target application. The _SetVRAMAddr() and _SetOrg() functions can be removed if the Virtual Displays feature is not used. The _SetLUTEntry() function can be removed if the custom palettes are not used in the project. For the descriptions of all the supported commands, refer to the chapter <b>Commands passed to the callback function</b> on page 1182 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</li>
</ul>
<h2><a class="anchor" id="group_emwin_spage_configuration"></a>
SPage Driver</h2>
<p>This section documents the main steps required to configure the SPage driver.</p>
<p>The explanation is based on the pre-customized files that are the part of emWin library and placed in the Config/MbedOS/SPage or Config/ModusToolbox/SPage catalog.</p>
<p>The LCD_X_Config() routine that is the part of LCDConf.c/LCDConf.cpp files implements the following functionality:</p><ol type="1">
<li>Create the GUIDRV_SPage driver instance with the desired display orientation, color depth, cache usage, palette, and link it to the desired layer. The pre-customized LCDConf.c/LCDConf.cpp files implements creation of the GUIDRV_SPAGE_1C0 option of the GUIDRV_SPage driver. This option defines the GUIDRV_SPage driver instance and links it to the 1-st layer with the following parameters:<ul>
<li>Orientation: Default</li>
<li>Color depth: 1-bpp</li>
<li>Cache usage: Not used</li>
<li>Palette: GUICC_1 (1-bpp black and white)<br />
 See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define DISPLAY_DRIVER GUIDRV_SPAGE_1C1</span></div><div class="line"><span class="preprocessor">#define COLOR_CONVERSION GUICC_1</span></div></div><!-- fragment --> <div class="fragment"><div class="line">GUI_DEVICE * pDevice;</div></div><!-- fragment --> <div class="fragment"><div class="line">pDevice = GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);</div></div><!-- fragment --> The user can change the COLOR_CONVERSION value to set up some other palette. For more information on palettes, refer to section Colors on page 1187 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>. The orientation, color depth and cache depend on the selected GUIDRV_SPage driver option and can be changed by user as well. For all supported GUIDRV_SPage driver and configuration macros for each option, refer to section <b>Color depth and display orientation</b> on page 1238 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</li>
</ul>
</li>
<li>Configure the physical display size with the desired value. The pre-customized LCDConf.c/LCDConf.cpp files have configured the physical display size with the default value of 180x132 pixels. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define XSIZE_PHYS 180</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 132</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (LCD_GetSwapXY())</div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, YSIZE_PHYS,   XSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, VYSIZE_PHYS,  VXSIZE_PHYS);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, XSIZE_PHYS,   YSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, VXSIZE_PHYS,  VYSIZE_PHYS);</div><div class="line">}</div></div><!-- fragment --> You can set custom display size by using the XSIZE_PHYS/YSIZE_PHYS defines.</li>
<li><p class="startli">Configure the display data RAM for the desired layer. The SPage driver does not require allocation of the display data RAM buffer in scope of the LCDConf.c/LCDConf.cpp files. It uses the memory buffer that is allocated in the GUIConf.c/GUIConf.cpp files. This display driver can be used with or without a display data cache. The data cache contains a complete copy of the LCD data RAM. If no cache is used, there are no additional RAM requirements.</p>
<p class="startli">SEGGER recommends using this driver with a data cache to improve the display performance. For details on the cache usage, refer to section GUIDRV_SPage on page 1240 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
</li>
<li>Configure the first segment address and the first common address to be used in the data RAM of the display controller. The pre-customized LCDConf.c/LCDConf.cpp files implements configuring the first segment address and the first common address with "0". See the corresponding code below: <div class="fragment"><div class="line">CONFIG_SPAGE Config = {0};</div></div><!-- fragment --> <div class="fragment"><div class="line">Config.FirstSEG = 0;</div><div class="line">Config.FirstCOM = 0;</div><div class="line">GUIDRV_SPage_Config(pDevice, &amp;Config);</div></div><!-- fragment --> The user can configure these values according to the used display memory layout. Refer to the display documentation.</li>
<li><p class="startli">Configure the display driver to work with the specified display controller. The pre-customized LCDConf.c/LCDConf.cpp files have configured the SPage display driver to work with any of the following controllers:</p><ul>
<li>Epson S1D15E05, S1D15E06, S1D15719, S1D15721</li>
<li>Integrated Solutions Technology IST3501</li>
</ul>
<p class="startli">See the corresponding code below: </p><div class="fragment"><div class="line">GUI_DEVICE * pDevice;</div><div class="line">GUI_PORT_API PortAPI = {0};</div></div><!-- fragment --> <div class="fragment"><div class="line">GUIDRV_SPage_SetBus8(pDevice, &amp;PortAPI);</div><div class="line">GUIDRV_SPage_Set1512(pDevice);</div></div><!-- fragment --><p class="startli">For a full list of the supported display controllers, refer to the <a class="el" href="index.html#group_emwin_display_drivers">Supported Display Drivers</a> section. The user can configure the SPage display driver to work with any supported display controller by calling the corresponding function (for example call the GUIDRV_SPage_SetST75256() function to configure the driver to use the Sitronix ST75256 controller). For information which function is used to set up operation with a particular display controller, refer to section <b>Run-time configuration</b> on page 1240 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a></p>
<p class="startli">The provided template does not implement any hardware interface. The user is responsible for selecting the appropriate communication interface (I2C, SPI, GPIO, etc...), for the hardware interface implementation on the application layer and for the initialization of the corresponding fields of the PortAPI structure in scope of the LCD_X_Config() routine. For a description of each interface, refer to section <b>Required GUI_PORT_API routines</b> on page 1242.</p>
</li>
</ol>
<p>It is also possible to add another user code if more configuration actions are required to achieve the desired parameters. For more information, refer to section <b>Run-time configuration</b> on page 1240 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<p>The LCD_X_DisplayDriver() routine requires the LCD_X_INITCONTROLLER command implementation in order to enable the display operation with the parameters, set in scope of the LCD_X_Config() routine. The pre-customized LCDConf.c/LCDConf.cpp files implement the LCD_X_DisplayDriver() routine template with the call of the empty function to handle the LCD_X_INITCONTROLLER command. See the corresponding code below.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _InitController(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line"> <span class="keywordtype">int</span> LCD_X_DisplayDriver(<span class="keywordtype">unsigned</span> LayerIndex, <span class="keywordtype">unsigned</span> Cmd, <span class="keywordtype">void</span> * pData)</div><div class="line"> {</div><div class="line">     <span class="keywordtype">int</span> r;</div><div class="line"></div><div class="line">     GUI_USE_PARA(LayerIndex);</div><div class="line">     GUI_USE_PARA(pData);</div><div class="line"></div><div class="line">     <span class="keywordflow">switch</span> (Cmd)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> LCD_X_INITCONTROLLER:</div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// Called during the initialization process in order to set up the</span></div><div class="line">            <span class="comment">// display controller and put it into operation. If the display</span></div><div class="line">            <span class="comment">// controller is not initialized by any external routine, this needs</span></div><div class="line">            <span class="comment">// to be adapted by the customer...</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            _InitController();</div><div class="line">            r = 0;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            r = -1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> r;</div><div class="line">}</div></div><!-- fragment --><p> The user is responsible for the _InitController() implementation with the initialization functionality for the used display controller. The user can also update this template to process any supported command if it is required by the target application. For descriptions of all supported commands, refer to section Commands passed to the callback function on page 1182 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<h2><a class="anchor" id="group_emwin_compactcolor16_configuration"></a>
CompactColor_16 Driver</h2>
<p>This section documents the main steps required to configure the CompactColor_16 driver.</p>
<p>The explanation is based on the pre-customized files that are part of emWin library and placed in the Config/MbedOS/CompactColor_16 or Config/ModusToolbox/CompactColor_16 catalog.</p>
<p>The LCD_X_Config() routine that is the part of LCDConf.c/LCDConf.cpp files implements the following functionality:</p><ol type="1">
<li>Create the GUIDRV_CompactColor_16 driver instance with the desired palette and link it to the desired layer. The pre-customized LCDConf.c/LCDConf.cpp files implement the creating of the GUIDRV_CompactColor_16 driver instance with the GUICC_M565 (16 bpp, red and blue swapped) palette and linking it to the 1-st layer. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define COLOR_CONVERSION GUICC_M565</span></div><div class="line"><span class="preprocessor">#define DISPLAY_DRIVER GUIDRV_COMPACT_COLOR_16</span></div></div><!-- fragment --> <div class="fragment"><div class="line">GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);</div></div><!-- fragment --> The user can change the COLOR_CONVERSION value to set up some other palette. For more information on palettes, refer to section Colors on page 1187 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</li>
<li>Configure the physical display size with the desired value. The pre-customized LCDConf.c/LCDConf.cpp files have configured the physical display size with the default value of 320x240 pixels. See the corresponding code below: <div class="fragment"><div class="line"><span class="preprocessor">#define XSIZE_PHYS 240</span></div><div class="line"><span class="preprocessor">#define YSIZE_PHYS 320</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (LCD_GetSwapXY())</div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, YSIZE_PHYS, XSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, YSIZE_PHYS, XSIZE_PHYS);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    LCD_SetSizeEx (0, XSIZE_PHYS, YSIZE_PHYS);</div><div class="line">    LCD_SetVSizeEx(0, XSIZE_PHYS, YSIZE_PHYS);</div><div class="line">}</div></div><!-- fragment --> The user can set the desired display size using the XSIZE_PHYS/YSIZE_PHYS defines.</li>
<li>Configure the display data RAM for the desired layer. The CompactColor_16 driver does not require allocation of the display data RAM buffer in scope of the LCDConf.c/LCDConf.cpp files. It uses the memory buffer that is allocated in the GUIConf.c/GUIConf.cpp files. This display driver can be used with and without a display data cache, containing a complete copy of the contents of the display data RAM. For details on the cache usage, refer to section GUIDRV_CompactColor_16 on page 1254 of <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</li>
<li><p class="startli">Configure the display driver to work with the specified display controller in the LCDConf_CompactColor_16.h This pre-customized file have configured the CompactColor_16 display driver to work with the Epson S1D19122, Ilitek ILI9342, ILI9481, and other controllers. See the corresponding code below: </p><div class="fragment"><div class="line"><span class="preprocessor">#define LCD_CONTROLLER          66709</span></div></div><!-- fragment --><p> The user can configure the CompactColor_16 display driver to work with any supported display controller by updating the LCD_CONTROLLER macro with the corresponding controller number. For all permitted values, refer to section <b>Controller selection()</b> on page 1254 of the <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
<p class="startli">The provided template does not implement any hardware interface. It provides a set of empty functions required for the 8-bit indirect interface implementation. The user is responsible for updating these functions with the code required to enable the communication through the used physical interface (GPIO for example). See the corresponding code below: </p><div class="fragment"><div class="line"><span class="preprocessor">#define LCD_USE_PARALLEL_16     0</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Display_WriteM8_A1(U8 *wrData, <span class="keywordtype">int</span> numbytes);</div><div class="line"><span class="keywordtype">void</span> Display_WriteM8_A0(U8 *wrData, <span class="keywordtype">int</span> numbytes);</div><div class="line"><span class="keywordtype">void</span> Display_ReadM8_A1(U8 *rdData, <span class="keywordtype">int</span> numbytes);</div><div class="line"><span class="keywordtype">void</span> Display_Write8_A0(U8 byte);</div><div class="line"><span class="keywordtype">void</span> Display_Write8_A1(U8 byte);</div><div class="line"></div><div class="line"><span class="preprocessor">#define LCD_WRITEM_A1(p, numbytes)  Display_WriteM8_A1(p, numbytes)</span></div><div class="line"><span class="preprocessor">#define LCD_WRITEM_A0(p, numbytes)  Display_WriteM8_A0(p, numbytes)</span></div><div class="line"><span class="preprocessor">#define LCD_READM_A1(p, numbytes)   Display_ReadM8_A1(p, numbytes)</span></div><div class="line"><span class="preprocessor">#define LCD_WRITE_A0(byte)          Display_Write8_A0(byte)</span></div><div class="line"><span class="preprocessor">#define LCD_WRITE_A1(byte)          Display_Write8_A1(byte)</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">void</span> Display_WriteM8_A1(U8 *wrData, <span class="keywordtype">int</span> numbytes)</div><div class="line">{</div><div class="line">    GUI_USE_PARA(wrData);</div><div class="line">    GUI_USE_PARA(numbytes);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Display_WriteM8_A0(U8 *wrData, <span class="keywordtype">int</span> numbytes)</div><div class="line">{</div><div class="line">    GUI_USE_PARA(wrData);</div><div class="line">    GUI_USE_PARA(numbytes);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Display_ReadM8_A1(U8 *rdData, <span class="keywordtype">int</span> numbytes)</div><div class="line">{</div><div class="line">    GUI_USE_PARA(rdData);</div><div class="line">    GUI_USE_PARA(numbytes);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Display_Write8_A0(U8 byte)</div><div class="line">{</div><div class="line">    GUI_USE_PARA(byte);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Display_Write8_A1(U8 byte)</div><div class="line">{</div><div class="line">    GUI_USE_PARA(byte);</div><div class="line">}</div></div><!-- fragment --><p> The user can also select another option for the communication interface (SPI for example) by defining a corresponding set of hardware access macros. For more information on the supported display controller interfaces, refer to section <b>Supported Hardware</b> on page 1253 of the <a href="./../../UM03001_emWin5.pdf"><b>emWin User Guide</b></a>.</p>
</li>
</ol>
<h2><a class="anchor" id="group_emwin_template_configuration"></a>
Template Driver</h2>
<p>The Template Driver driver can be used as a starting point to implement a custom display driver. It contains the complete functionality needed for a display driver.</p>
<p>There are no specific requirements regarding the Template Driver configuration because it depends on the Template Driver user implementation.</p>
<h1><a class="anchor" id="section_emwin_toolchain"></a>
Supported Software and Tools</h1>
<p>This version of the emWin middleware was validated for the compatibility with the following software and tools:</p>
<table class="doxtable">
<tr>
<th>Software and Tools </th><th>Version  </th></tr>
<tr>
<td>ModusToolbox Software Environment </td><td>2.0  </td></tr>
<tr>
<td>PSoC6 Peripheral Driver Library (PDL) </td><td>1.2.0  </td></tr>
<tr>
<td>GCC Compiler </td><td>7.2.1  </td></tr>
<tr>
<td>IAR Compiler </td><td>8.32  </td></tr>
<tr>
<td>Arm Compiler 6 </td><td>6.11  </td></tr>
<tr>
<td>Mbed OS </td><td>5.13.3  </td></tr>
<tr>
<td>FreeRTOS </td><td>10.0.1  </td></tr>
</table>
<h1><a class="anchor" id="section_emwin_known_issues"></a>
Known Issues</h1>
<table class="doxtable">
<tr>
<th>Problem </th><th>Workaround  </th></tr>
<tr>
<td>emWin operates incorrectly with a floating point when a project is compiled with IAR or ARM Compiler 6 within MbedOS. <br />
 This is caused by the inconsistent floating-point ABI selection between toolchains in MbedOS: <br />
 <a href="https://github.com/ARMmbed/mbed-os/issues/9153">https://github.com/ARMmbed/mbed-os/issues/9153</a>  </td><td>To avoid the incorrect operation, use one of the following workarounds: <br />
<ol type="1">
<li>Use the GCC toolchain for MbedOS emWin projects. <br />
</li>
<li>Manually replace the emWin softfp library with its hardfp version. For example, for NOSNTS emWin core variant and IAR toolchain, replace the library in <br />
 GUI/COMPONENT_SOFTFP/COMPONENT_EMWIN_NOSNTS/TOOLCHAIN_IAR <br />
 with the library from <br />
 GUI/COMPONENT_HARDFP/COMPONENT_EMWIN_NOSNTS/TOOLCHAIN_IAR.   </li>
</ol>
</td></tr>
</table>
<h1><a class="anchor" id="group_emwin_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="4">5.48.1 </td><td>Updated emWin hardfp libraries for ARM Compiler 6 </td><td>Fixing linker error  </td></tr>
<tr>
<td>Added ModusToolbox support </td><td>ModusToolbox flow support  </td></tr>
<tr>
<td>Added emWin PC Tools to support emWin GUI development </td><td>User experience improvement  </td></tr>
<tr>
<td>Updated documentation </td><td>User experience improvement  </td></tr>
<tr>
<td rowspan="1">5.48.0 </td><td>Initial release with PSoC6 Mbed targets support </td><td>Mbed flow support  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>SEGGER emWin graphics library 5.48.1</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
