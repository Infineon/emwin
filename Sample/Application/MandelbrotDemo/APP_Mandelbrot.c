/*********************************************************************
*                SEGGER Microcontroller GmbH                         *
*        Solutions for real time microcontroller applications        *
**********************************************************************
*                                                                    *
*        (c) 1996 - 2021  SEGGER Microcontroller GmbH                *
*                                                                    *
*        Internet: www.segger.com    Support:  support@segger.com    *
*                                                                    *
**********************************************************************

** emWin V6.24 - Graphical user interface for embedded applications **
All  Intellectual Property rights  in the Software belongs to  SEGGER.
emWin is protected by  international copyright laws.  Knowledge of the
source code may not be used to write a similar product.  This file may
only be used in accordance with the following terms:

The software  has been licensed to  Cypress Semiconductor Corporation,
whose registered  office is situated  at 198 Champion Ct. San Jose, CA 
95134 USA  solely for the  purposes of creating  libraries for Cypress
PSoC3 and  PSoC5 processor-based devices,  sublicensed and distributed
under  the  terms  and  conditions  of  the  Cypress  End User License
Agreement.
Full source code is available at: www.segger.com

We appreciate your understanding and fairness.
----------------------------------------------------------------------
Licensing information
Licensor:                 SEGGER Microcontroller Systems LLC
Licensed to:              Cypress Semiconductor Corp, 198 Champion Ct., San Jose, CA 95134, USA
Licensed SEGGER software: emWin
License number:           GUI-00319
License model:            Cypress Services and License Agreement, signed June 9th/10th, 2009
                          and Amendment Number One, signed June 28th, 2019 and July 2nd, 2019
                          and Amendment Number Two, signed September 13th, 2021 and September 18th, 2021
Licensed platform:        Any Cypress platform (Initial targets are: PSoC3, PSoC5)
----------------------------------------------------------------------
Support and Update Agreement (SUA)
SUA period:               2009-06-12 - 2022-07-27
Contact to extend SUA:    sales@segger.com
----------------------------------------------------------------------
File        : APP_Mandelbrot.c
Purpose     : Mandelbrot demo
----------------------------------------------------------------------
*/
#include "DIALOG.h"

#include "Resource.h"

#define USE_DOUBLE  0

#if  defined(WIN32) || (USE_DOUBLE == 1)
  #define FLOAT  double
#else
  #define FLOAT  float
#endif

/*********************************************************************
*
*       Static (const) data
*
**********************************************************************
*/

static const char* _apText[] = {
  "",
  "Calculate",
  "Back",
  "Use touch to\nselect range",
  "Max depth reached",
};

static const char* _apHeaderSpecific[] = {
    "Mandelbrot Help",
    "Enjoy the Mandelbrot demo!",
};

static const char* _apSmallHeader[] = {
  "Info:",
  "Usage Guide:"
};

static const char* _apBody[] = {
  "A Mandelbrot image is generated by resolving an algebraic function for a series of complex numbers and is used as an example of calculation intensive activity for any CPU.\nThis demo is a good indicator on how good the hardware can handle floating values.",
  "Using the touch screen to plot opposite corners of a rectangular area, you can zoom in to the Mandelbrot set image and define the next set of fractal calculations in real time. With the Back button you will go back to the previous shown screen of the Mandelbrot image."
};

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

static MANDEL_RANGE aRange[MAX_DEPTH];

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       DrawMandelbrot_FPU
*/
static void _DrawMandelbrot_FPU(WM_MESSAGE * pMsg, MANDEL_DATA * pData, int x0, int y0, int x1, int y1) {
  FLOAT            x, y;
  FLOAT            u, v;
  FLOAT            dx, dy, u2, v2;
  int              i, j, k, s;
  int              xSize, ySize;
  int              IsInner;
  int              xOrg, yOrg;
  int              xPos, yPos;
  WM_HWIN          hWin;
  const GUI_RECT * pClipRect;
  GUI_PID_STATE    State;
  WM_HWIN          hButton;
  WM_HWIN          hHelp;
  WM_HWIN          hFound;

  pClipRect = GUI_GetClipRect();
  hWin = pMsg->hWin;
  xOrg = WM_GetWindowOrgX(hWin);
  yOrg = WM_GetWindowOrgY(hWin);
  xSize = x1 - x0 + 1;
  ySize = y1 - y0 + 1;
  dx = (pData->Range.xMax - pData->Range.xMin) / xSize;
  dy = (pData->Range.yMax - pData->Range.yMin) / ySize;
  IsInner = 0;

  for (i = ySize / 2, s = 1; i >= 1; i >>= 1, s *= 2);
  do {
    for (j = s - 1; j < ySize; j += s + s) {
      yPos = y1 - j + yOrg;
      if ((yPos >= pClipRect->y0) && (yPos <= pClipRect->y1)) {
        y = pData->Range.yMax - j * dy;
        for (i = 0; i < xSize; i++) {
          xPos = x0 + i + xOrg;
          if ((xPos >= pClipRect->x0) && (xPos <= pClipRect->x1)) {
            u = v = u2 = v2 = 0;
            x = pData->Range.xMin + i * dx;
            //
            // Iterate the point
            //
            for (k = 0; (k < pData->MaxIter) && (u2 + v2 < 4.0); k++) {
              v = 2 * u * v + y;
              u = u2 - v2 + x;
              u2 = u * u;
              v2 = v * v;
            }
            //
            // Compute pixel color
            //
            if (k >= pData->MaxIter) {
              //
              // Interior
              //
              if (IsInner == 0) {
                IsInner = 1;
                GUI_SetColor(GUI_BLACK);
              }
            } else {
              //
              // Exterior
              //
              IsInner = 0;
              GUI_SetColor(*(pData->pColor + (k % pData->NumColors)));
            }
            if (s > 1) {
              LCD_DrawVLine(xPos, y1 - j - s + 1 + yOrg, yPos);
            } else {
              LCD_DrawPixel(xPos, yPos);
            }
            if (GUI_TOUCH_GetState(&State)) {
              hButton = WM_GetDialogItem(WM_GetParent(pMsg->hWin), ID_BUTTON_BACK);
              hHelp   = WM_GetDialogItem(WM_GetParent(pMsg->hWin), ID_BUTTON_HELP);
              hFound  = WM_Screen2hWin(State.x, State.y);
              if (hFound == hHelp) {
                return;
              }
              if (hButton == hFound) {
                if (pData->Depth > 0) {
                  return;
                }
              } else {
                return;
              }
            }
          }
        }
      }
    }
  } while (s >>= 1);
}

/*********************************************************************
*
*       _ButtonSkin
*/
static int _ButtonSkin(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo) {
  switch (pDrawItemInfo->Cmd) {
  case WIDGET_ITEM_DRAW_BACKGROUND:
    GUI_SetColor(COLOR_SHAPE);
    GUI_FillRect(pDrawItemInfo->x0, pDrawItemInfo->y0, pDrawItemInfo->x1, pDrawItemInfo->y1);
    GUI_SetColor(BUTTON_IsPressed(pDrawItemInfo->hWin) ? COLOR_BUTTON_1 : COLOR_BUTTON_0);
    GUI_FillRect(pDrawItemInfo->x0 + PENSIZE, pDrawItemInfo->y0 + PENSIZE, pDrawItemInfo->x1 - PENSIZE, pDrawItemInfo->y1 - PENSIZE);
    return 0;
  default:
    return BUTTON_DrawSkinFlex(pDrawItemInfo);
  }
}

/*********************************************************************
*
*       _DrawSelectionRect
*/
static void _DrawSelectionRect(GUI_RECT * pRect, MANDEL_DATA * pData) {
  int temp;

  pData->x0 = pRect->x0;
  pData->y0 = pRect->y0;
  pData->x1 = pRect->x1;
  pData->y1 = pRect->y1;
  if (pData->x1 < pData->x0) {
    temp = pData->x1;
    pData->x1 = pData->x0;
    pData->x0 = temp;
  }
  if (pData->y1 < pData->y0) {
    temp = pData->y1;
    pData->y1 = pData->y0;
    pData->y0 = temp;
  }
  GUI_SetDrawMode(GUI_DM_XOR);
  GUI_DrawRect(pData->x0, pData->y0, pData->x1, pData->y1);
  pData->IsVis ^= 1;
}

/*********************************************************************
*
*       _SetupButton
*/
static void _SetupButton(WM_HWIN hWin, int Id, int Enable, int IndexText) {
  WM_HWIN     hItem;
  const char* pText;

  hItem = WM_GetDialogItem(hWin, Id);
  if (Enable) {
    WM_EnableWindow(hItem);
  } else {
    WM_DisableWindow(hItem);
  }
  pText = (IndexText >= 0) ? _apText[IndexText] : NULL;
  if (pText) {
    BUTTON_SetText(hItem, pText);
  }
  if ((Id == ID_BUTTON_BACK) && (IndexText == TEXT_EXIT)) {
    WM_HideWindow(hItem);
  } else {
    WM_ShowWindow(hItem);
  }
  WM_Paint(hItem);
}

/*********************************************************************
*
*       _CreatePalette
*/
static void _CreatePalette(MANDEL_DATA * pData) {
  static const GUI_COLOR aGradient[] = {
    GUI_MAKE_COLOR(0xA02020), GUI_MAKE_COLOR(0xFF20FF), GUI_MAKE_COLOR(0x20FFFF), GUI_MAKE_COLOR(0x2020FF)
  };
  static U32 aColor[256];
  int        i, j, BitsPerPixel;
  GUI_COLOR* p;

  BitsPerPixel = LCD_GetBitsPerPixel();
  pData->NumColors = (BitsPerPixel <= 8) ? 1 << BitsPerPixel : 0;
  if ((pData->NumColors <= 256) && (pData->NumColors != 0)) {
    //
    // Use hardware palette
    //
    pData->pColor = aColor;
    for (i = 0; i < pData->NumColors; i++) {
      *(pData->pColor + i) = LCD_Index2Color(i);
    }
  } else {
    //
    // Calculate palette with above defined colors
    //
    pData->NumColors = 0x40;
    pData->pColor = p = aColor;
    for (j = 0; j < 4; j++) {
      for (i = 0x00; i < (pData->NumColors >> 2); i++) {
        *p++ = LCD_MixColors256(aGradient[(j + 1) & 3], aGradient[j], ((i + 1) * (0x400 / pData->NumColors)) - 1);
      }
    }
  }
}

/*********************************************************************
*
*       _CalcRange
*/
static void _CalcRange(MANDEL_DATA * pData) {
  FLOAT xMin, xMax, yMin, yMax, mx, my, dx, dy;

  //
  // Calculate new values
  //
  xMin = pData->Range.xMin + ((pData->Range.xMax - pData->Range.xMin) * pData->x0) / pData->xSize;
  xMax = pData->Range.xMin + ((pData->Range.xMax - pData->Range.xMin) * pData->x1) / pData->xSize;
  yMin = pData->Range.yMin + ((pData->Range.yMax - pData->Range.yMin) * pData->y0) / pData->ySize;
  yMax = pData->Range.yMin + ((pData->Range.yMax - pData->Range.yMin) * pData->y1) / pData->ySize;
  mx = (xMin + xMax) / 2;
  my = (yMin + yMax) / 2;
  dx = xMax - xMin;
  dy = yMax - yMin;
  //
  // Keep aspect ratio
  //
  if (dx > dy) {
    dy = (dx * pData->ySize) / pData->xSize;
    yMin = my - dy / 2;
    yMax = my + dy / 2;
  } else {
    dx = (dy * pData->xSize) / pData->ySize;
    xMin = mx - dx / 2;
    xMax = mx + dx / 2;
  }
  //
  // Use new values
  //
  pData->Range.xMin = xMin;
  pData->Range.xMax = xMax;
  pData->Range.yMin = yMin;
  pData->Range.yMax = yMax;
}

/*********************************************************************
*
*       _PushRange
*/
static int _PushRange(MANDEL_DATA * pData, MANDEL_RANGE * pRange) {
  if (pData->Depth == (MAX_DEPTH - 1)) {
    return 1;
  }
  *(pRange + pData->Depth) = pData->Range;
  pData->Depth++;
  return 0;
}

/*********************************************************************
*
*       _PopRange
*/
static int _PopRange(MANDEL_DATA * pData, MANDEL_RANGE * pRange) {
  if (pData->Depth == 0) {
    return 1;
  }
  pData->Range = *(pRange + pData->Depth - 1);
  pData->Depth--;
  return 0;
}

/*********************************************************************
*
*       _DrawText
*/
static void _DrawText(GUI_RECT * pRect) {
  GUI_RECT RTemp;
  GUI_RECT Rect;
  
  Rect.x0 = 0;
  Rect.y0 = pRect->y0 - 10;
  Rect.x1 = LCD_GetXSize() - 1;
  Rect.y1 = Rect.y0 + 60;
  GUI_SetColor(COLOR_BLUE);
  GUI_FillRectEx(&Rect);
  GUI_SetTextMode(GUI_TM_TRANS);
  GUI_SetColor(GUI_WHITE);
  //
  // Fill a temporary rectangle since we need to adapt it while drawing
  //
  RTemp.x0 = pRect->x0;
  RTemp.y0 = pRect->y0 - 8;
  RTemp.x1 = pRect->x1;
  RTemp.y1 = pRect->y1;
  //
  // Display the main header with the biggest font and shrink the rectangle about the
  // y size of the font multiplied with the number of lines required
  //
  GUI_SetFont(FONT_HEADER);
  GUI_DispStringInRectWrap(_apHeaderSpecific[0], &RTemp, GUI_TA_HCENTER | GUI_TA_TOP, GUI_WRAPMODE_WORD);
  RTemp.y0 += GUI_WrapGetNumLines(_apHeaderSpecific[0], RTemp.x1 - RTemp.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
  //
  // Display two other header with the medium font and shrink the rectangle again
  //
  GUI_SetFont(FONT_HBODY);
  GUI_DispStringInRectWrap(_apHeaderSpecific[1], &RTemp, GUI_TA_HCENTER | GUI_TA_TOP, GUI_WRAPMODE_WORD);
  RTemp.y0 += GUI_WrapGetNumLines(_apHeaderSpecific[1], RTemp.x1 - RTemp.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + 12;
  GUI_SetColor(GUI_BLACK);
  GUI_DispStringInRectWrap(_apSmallHeader[0], &RTemp, GUI_TA_LEFT | GUI_TA_TOP, GUI_WRAPMODE_WORD);
  RTemp.y0 += GUI_WrapGetNumLines(_apSmallHeader[0], RTemp.x1 - RTemp.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
  //
  // Display the first body text
  //
  GUI_SetFont(FONT_BODY);
  GUI_DispStringInRectWrap(_apBody[0], &RTemp, GUI_TA_LEFT | GUI_TA_TOP, GUI_WRAPMODE_WORD);
  RTemp.y0 += (GUI_WrapGetNumLines(_apBody[0], RTemp.x1 - RTemp.x0, GUI_WRAPMODE_WORD) + 1) * GUI_GetFontDistY();
  //
  // Another header
  //
  GUI_SetFont(FONT_HBODY);
  GUI_DispStringInRectWrap(_apSmallHeader[1], &RTemp, GUI_TA_LEFT | GUI_TA_TOP, GUI_WRAPMODE_WORD);
  RTemp.y0 += GUI_WrapGetNumLines(_apSmallHeader[1], RTemp.x1 - RTemp.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
  //
  // Display the second body text
  //
  GUI_SetFont(FONT_BODY);
  GUI_DispStringInRectWrap(_apBody[1], &RTemp, GUI_TA_LEFT | GUI_TA_TOP, GUI_WRAPMODE_WORD);
  RTemp.y0 += (GUI_WrapGetNumLines(_apBody[1], RTemp.x1 - RTemp.x0, GUI_WRAPMODE_WORD) + 1) * GUI_GetFontDistY();
}

/*********************************************************************
*
*       _cbMandelbrot
*/
static void _cbMandelbrot(WM_MESSAGE * pMsg) {
  static GUI_RECT            Rect;
  MANDEL_DATA*               pData;
  GUI_RECT                   RectWindow;
  WM_PID_STATE_CHANGED_INFO* pInfo;
  GUI_PID_STATE*             pState;

  switch (pMsg->MsgId) {
  case WM_PID_STATE_CHANGED:
    //
    // Draw the selction rectangle
    //
    WM_GetUserData(pMsg->hWin, &pData, sizeof(pData));
    pInfo = (WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
    if ((pInfo->State == 1) && (pInfo->StatePrev == 0)) {
      if (pData->IsVis) {
        _DrawSelectionRect(&Rect, pData);
      }
      pData->IsDown = 1;
      Rect.x0 = pInfo->x;
      Rect.y0 = pInfo->y;
    } else if ((pInfo->State == 0) && (pInfo->StatePrev == 1)) {
      pData->IsDown = 0;
    }
    break;
  case WM_TOUCH:
    WM_GetUserData(pMsg->hWin, &pData, sizeof(pData));
    if (pData->IsDown) {
      WM_SelectWindow(pMsg->hWin);
      if (pData->IsVis) {
        _DrawSelectionRect(&Rect, pData);
      }
      pState = (GUI_PID_STATE *)pMsg->Data.p;
      if (pState) {
        Rect.x1 = pState->x;
        Rect.y1 = pState->y;
        _DrawSelectionRect(&Rect, pData);
      }
    } else {
      if (_PushRange(pData, aRange) == 0) {
        _CalcRange(pData);
        WM_InvalidateWindow(pData->hWin);
        pData->IsDown = pData->IsVis = 0;
        //
        // Depending on the depth, change back button text
        //
        if (pData->Depth == MAX_DEPTH - 1) {
          _SetupButton(WM_GetParent(WM_GetParent(pMsg->hWin)), ID_BUTTON_BACK, 1, TEXT_MAX);
        } else {
          _SetupButton(WM_GetParent(WM_GetParent(pMsg->hWin)), ID_BUTTON_BACK, 1, TEXT_BACK);
        }
      }
    }
    break;
  case WM_PAINT:
    //
    // Get user data
    //
    WM_GetUserData(pMsg->hWin, &pData, sizeof(pData));
    //
    // Draw mandelbrot
    //
    if (pData) {
      WM_GetClientRect(&RectWindow);
      GUI_SetColor(GUI_BLACK);
      GUI_DrawRectEx(&RectWindow);
      GUI__ReduceRect(&RectWindow, &RectWindow, 1);
      WM_SetUserClipRect(&RectWindow);
      _DrawMandelbrot_FPU(pMsg, pData, RectWindow.x0, RectWindow.y0, RectWindow.x1, RectWindow.y1);
      WM_SetUserClipRect(NULL);
    }
    break;
  default:
    WM_DefaultProc(pMsg);
  }
}

/*********************************************************************
*
*       _cbHelp
*/
static void _cbHelp(WM_MESSAGE * pMsg) {
  WM_HWIN           hButton;
  int               xSizeWindow;
  int               Id;
  int               NCode;
  static GUI_RECT   TRect;
  WM_MOTION_INFO*   pInfo;
  static int        yStart;
  static int        yEnd;

  switch (pMsg->MsgId) {
  case WM_MOTION:
    pInfo = (WM_MOTION_INFO *)pMsg->Data.p;
    switch (pInfo->Cmd) {
    case WM_MOTION_INIT:
      //
      // Tell the motion module to move in y direction and that we manage it on our own
      //
      pInfo->Flags = WM_CF_MOTION_Y | WM_MOTION_MANAGE_BY_WINDOW;
      break;
    case WM_MOTION_MOVE:
      //
      // Move the text rectangle up or down
      //
      TRect.y0 += pInfo->dy;
      TRect.y1 += pInfo->dy;
      if (TRect.y0 < -yEnd) {
        //
        // If reach the end, make sure we stpo there
        //
        TRect.y0 = -yEnd;
        TRect.y1 = LCD_GetYSize();
        pInfo->StopMotion = 1;
      } else if (TRect.y0 > yStart) {
        //
        // If reach the top, make sure we stpo there
        //
        TRect.y0 = yStart;
        TRect.y1 = yEnd + LCD_GetYSize();
        pInfo->StopMotion = 1;
      }
      //
      // Tell the window to redraw
      //
      WM_InvalidateWindow(pMsg->hWin);
      break;
    case WM_MOTION_GETPOS:
      pInfo->yPos = TRect.y0;
      break;
    }
    break;
  case WM_CREATE:
    WM_MULTIBUF_Enable(1);
    xSizeWindow = WM_GetWindowSizeX(pMsg->hWin);
    //
    // Create exit button
    //
    hButton = BUTTON_CreateUser(xSizeWindow - XSIZE_BUTTON - BORDER, BORDER, XSIZE_BUTTON, YSIZE_BUTTON, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_EXIT, 0);
    BUTTON_SetSkin(hButton, _ButtonSkin);
    BUTTON_SetText(hButton, "EXIT");
    BUTTON_SetFont(hButton, FONT_SMALL);
    //
    // Make sure it fits between the buttons to the left and right
    //
    TRect.x0 = BORDER + BORDER / 2;
    TRect.x1 = xSizeWindow - BORDER - BORDER / 2;
    //
    // Start with a small distance to the top
    //
    TRect.y0 = BORDER;
    //
    // Start calculating the end of the rectangle
    // 1 header with a big font
    // 3 header with a medium font
    // 2 body texts with a small font + 2 extra lines for spacing
    //
    GUI_SetFont(FONT_HEADER);
    TRect.y1 = GUI_WrapGetNumLines(_apHeaderSpecific[0], TRect.x1 - TRect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
    GUI_SetFont(FONT_HBODY);
    TRect.y1 += GUI_WrapGetNumLines(_apHeaderSpecific[1], TRect.x1 - TRect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
    TRect.y1 += GUI_WrapGetNumLines(_apSmallHeader[0], TRect.x1 - TRect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
    TRect.y1 += GUI_WrapGetNumLines(_apSmallHeader[1], TRect.x1 - TRect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();
    GUI_SetFont(FONT_BODY);
    TRect.y1 += (GUI_WrapGetNumLines(_apBody[0], TRect.x1 - TRect.x0, GUI_WRAPMODE_WORD) + 1) * GUI_GetFontDistY();
    TRect.y1 += (GUI_WrapGetNumLines(_apBody[1], TRect.x1 - TRect.x0, GUI_WRAPMODE_WORD) + 1) * GUI_GetFontDistY();
    //
    // If the display is large enough to hold the text, disable motion support
    //
    if (TRect.y1 < LCD_GetYSize() - 1) {
      WM_MOTION_Enable(0);
    }
    //
    // Remember the start and the end of the rectangle
    //
    yStart = TRect.y0;
    yEnd   = TRect.y1 - LCD_GetYSize();
    break;
  case WM_NOTIFY_PARENT:
    Id = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch (Id) {
    case ID_BUTTON_EXIT:
      switch (NCode) {
      case WM_NOTIFICATION_RELEASED:
        //
        // On exit, delete this window
        //
        WM_DeleteWindow(pMsg->hWin);
        break;
      }
      break;
    }
    break;
  case WM_PAINT:
    //
    // Clear background
    //
    GUI_SetBkColor(COLOR_BK);
    GUI_Clear();
    //
    // Display the help text
    //
    _DrawText(&TRect);
    break;
  case WM_DELETE:
    //
    // Disable multi buffering
    //
    WM_MULTIBUF_Enable(0);
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbWin
*/
static void _cbWin(WM_MESSAGE * pMsg) {
  int                Id;
  int                NCode;
  int                xSizeWindow;
  int                ySizeWindow;
  static int         BkIsClear;
  static MANDEL_DATA Data;
  MANDEL_DATA*       pData = &Data;
  WM_HWIN            hItem;

  switch (pMsg->MsgId) {
  case WM_DELETE:
    pData->Depth = 0;
    BkIsClear = 0;
    break;
  case WM_CREATE:
    //
    // Get size of this window
    //
    xSizeWindow = WM_GetWindowSizeX(pMsg->hWin);
    ySizeWindow = WM_GetWindowSizeY(pMsg->hWin);
    //
    // Create exit button
    //
    //
    // Set up initial Mandelbrot range
    //
    pData->MaxIter = MAX_ITER;
    pData->xSize = xSizeWindow - (2 * FRAME_X);
    pData->ySize = ySizeWindow - (2 * FRAME_Y);
    pData->Range.xMin = -2.3f;
    pData->Range.xMax = +1.3f;
    pData->Range.yMin = -((pData->Range.xMax - pData->Range.xMin) * pData->ySize * 0.5f) / pData->xSize;
    pData->Range.yMax = +((pData->Range.xMax - pData->Range.xMin) * pData->ySize * 0.5f) / pData->xSize;
    //
    // Create Mandelbrot window
    //
    pData->hWin = WM_CreateWindowAsChild(FRAME_X, FRAME_Y, pData->xSize, pData->ySize, pMsg->hWin, 0, _cbMandelbrot, sizeof(pData));
    WM_SetUserData(pData->hWin, &pData, sizeof(pData));
    //
    // Initialize palette to be used
    //
    _CreatePalette(pData);
    //
    // Create back button
    //
    hItem = BUTTON_CreateUser(BORDER, BORDER, XSIZE_BUTTON, YSIZE_BUTTON, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_BACK, 0);
    WM_ClrHasTrans(hItem);
    BUTTON_SetSkin(hItem, _ButtonSkin);
    _SetupButton(pMsg->hWin, ID_BUTTON_BACK, 1, TEXT_SELECT);
    //
    // Create help button
    //
    hItem = BUTTON_CreateUser(xSizeWindow - XSIZE_BUTTON - BORDER, BORDER, XSIZE_BUTTON, YSIZE_BUTTON, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_HELP, 0);
    WM_ClrHasTrans(hItem);
    BUTTON_SetSkin(hItem, _ButtonSkin);
    BUTTON_SetFont(hItem, FONT_SMALL);
    BUTTON_SetText(hItem, "HELP");
    break;
  case WM_PAINT:
    GUI_SetBkColor(COLOR_BK);
    GUI_Clear();
    GUI_SetColor(GUI_BLACK);
    GUI_SetFont(FONT_MEDIUM);
    GUI_SetTextAlign(GUI_TA_CENTER | GUI_TA_BOTTOM);
    //
    // Make sure to show the window after the background is properly cleared
    //
    if (BkIsClear == 0) {
      WM_ShowWindow(pData->hWin);
      BkIsClear = 1;
    }
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_BACK: // 'Back'
      switch(NCode) {
      case WM_NOTIFICATION_RELEASED:
        //
        // On back button release
        //
        if (_PopRange(pData, aRange) == 0) {  // Get previous zoom
          pData->IsDown = pData->IsVis = 0;
          WM_InvalidateWindow(pData->hWin);   // Invalidate mandelbrot window
          //
          // Depending on the zoom lvl (depth) change back button text
          //
          if (pData->Depth == 0) {
            _SetupButton(WM_GetParent(pMsg->hWin), ID_BUTTON_BACK, 1, TEXT_SELECT);
            //
            // Make sure it is immediately visible
            //
            WM_Paint(pData->hWin);
          } else {
            _SetupButton(WM_GetParent(pMsg->hWin), ID_BUTTON_BACK, 1, TEXT_BACK);
          }
        }
        break;
      }
      break;
    case ID_BUTTON_HELP:
      switch (NCode) {
      case WM_NOTIFICATION_CLICKED:
        //
        // Creaete help dialog
        //
        WM_CreateWindow(0, 0, LCD_GetXSize(), LCD_GetYSize(), WM_CF_SHOW | WM_CF_MOTION_Y, _cbHelp, 0);
        break;
      }
      break;
    }
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       MainTask
*/
void MainTask(void) {
  GUI_Init();
  //
  // Enable motion support
  //
  WM_MOTION_Enable(1);
  BUTTON_SetReactOnLevel();
  //
  // Create window for managing mandelbrot and buttons
  //
  WM_CreateWindow(0, 0, LCD_GetXSize(), LCD_GetYSize(), WM_CF_SHOW, _cbWin, 0);
  while (1) {
    GUI_Delay(100);
  }
}

/*************************** End of file ****************************/
